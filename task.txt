Базовое задание
Задача 1
Морфинг геометрии 
Цель задания  
Более детально освоить преобразования вершин (vertex shader); 
Научиться анимировать объекты, используя юниформы (uniforms).
 Задача в общих словах 
Используя вершинный шейдер, необходимо реализовать один из вариантов морфинга геометрии:  
куба в сферу;  
закручивание цилиндра вокруг своей оси;  
произвольной модели в сферу/куб;  
любые другие ваши идеи:

Приблизительный алгоритм выполнения задания 
Опишем алгоритм, например, решения задачи морфинга куба в сферу.  
Взять приложения из задачи 1 и реализовать в нем возможность создания геометрии (модели) куба 
из большого количества вершин на каждой стороне кубика. То есть на одной стороне(грани) куба должно быть не 4 вершины (по углам грани), 
а гораздо больше. Например, на рисунке ниже сторона разделена на 4х4 квадрата, 
она содержит 25 вершин, из которых нужно собрать 32 треугольника.
 

Поддержать возможность передачи uniform переменной в вершинный шейдер с текущим временем или с некоторым параметром, варьирующимся от 0 до 1 (нужно будет для дальнейшего морфирования).  
Нагуглить формулы для морфирования, поддержать их в вершинном шейдере (учесть параметр выше). Замечание: способов морфирования может быть несколько, выберите наиболее удобный вам и легко параметризующийся.  
В основном коде изменять параметр морфирования, например, варьировать значение параметра от 0,0 до 1,0.  
Нарисовать «каркас модели» — точки и полилинии, поддержать его морфинг и посмотреть на результат.  
Обратите внимание на задание разных цветов в вершинах (если цвет везде одинаковый, то визуально невозможно определить на сколько частей разбита каждая грань куба)
Дополнительно можно  
Данный вариант морфинга можно считать «устаревшим», т.к. не используется «параллелизм», обеспеченный вам графическим ускорителем и API. Поэтому предлагается использовать дополнительные шейдеры — тесселяционный и геометрический, чтобы реализовать морфинг на упрощенной исходной геометрии. Затем получить визуально похожую картинку с морфингом, сделанным с помощью вершинного шейдера, сравнить количество вершин в изначальной геометрии для двух вариантов, а также попробовать оценить производительность. 
Полезные ссылки
https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.3.30.pdf — GLSL 3.30 specification.  
https://www.khronos.org/opengl/wiki/GLSL_Object — Program objects (shaders objects).
https://www.khronos.org/opengl/wiki/Uniform_(GLSL) — GLSL uniforms.  http://www.opengl-tutorial.org — OpenGL tutorials.
http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html — Morphing cube to sphere.
http://mathproofs.blogspot.com/2005/07/mapping-square-to-circle.html — Morphing square to circle.
https://mathematica.stackexchange.com/questions/174847/transform-sphere-into-a-cube — Some formulas and explanations.

Задача 2 
Рендеринг с учетом освещения в вершинах 
Цель задания
Реализовать в вершинном шейдере формулу Фонга для локальной модели освещения;  
Реализовать формулу для разных типов источников света (направленный свет, точечный источник света, прожектор). 
Задача в общих словах 
Одноцветный кубик должен иметь разную интенсивность/яркость цвета на гранях с разным углом поворота к источнику освещения (в соответствии с формулой Фонга). 
Приблизительный алгоритм выполнения задания  
Взять приложение из задачи 1.  
Написать вершинный шейдер, реализующий локальную модель освещения по Фонгу.  
Задать источники освещения всех типов (направленный свет, точечный источник света, прожектор) и фоновое освещение. Задавать их цвета из интерфейса пользователя.  
Задать разные коэффициенты материала для всех трех компонент в формуле Фонга – цвет материала для Ambient, цвет материала для Diffuse, цвет материала для Specular. 
Уметь задавать все три цвета из интерфейса пользователя. 
Подобрать наиболее красивое сочетание всех трех компонент цветов материалов при очень разных цветах источников света. Например, фоновое освещение красноватого оттенка, направленный свет – светло-желтый, точечный источник света и прожектор – светлоголубой.
Дополнительно можно  
Задать несколько точечных источников света, автоматически перемещающихся над плоскостью с объектами. Важно, чтобы интенсивность света сильно различалась для ближних и дальних объектов (расстояние между объектами и источником света сравнимо с расстоянием между объектами). 
Обратите внимание, что формула для компоненты освещения Ambient включает две составляющие: Ca и Ga. Ca это цвет материала, а Ga – цвет фонового освещения. Нужно обязательно перемножать одного на другое, поскольку при освещении зеленого шарика красным светом мы шарик не увидим (он будет черным)! Аналогично есть Cd и Ld. Cd – цвет материала, Ld – цвет солнышка. И Cs и Ls. Cs – цвет материала и Ls – цвет солнышка. В итоге получается три цвета материала Ca, Cd и Cs. Они могут быть разными, хотя и похожими.

Задача 3
Расчет и отображение скорости рендеринга 
Цель задания  
Научиться работать с текстом (двумерным);  
Научиться точно измерять время; 
Задача в общих словах 
Создать сцену из очень большого числа одинаковых объектов, расположенных рядом (в одной плоскости) и осветить ее разными источниками света. Измерять и отображать скорость рендеринга сложной сцены (число кадров в секунду). При изменении сложности сцены частота кадров должна адекватно изменяться.
Приблизительный алгоритм выполнения задания  
Взять приложение из задачи 2.  
Встроить в приложение код отображения большого количества объектов, равномерно располагая их в горизонтальной плоскости (так, чтобы все объекты были видны). Объект один, но он повторяется в сцене заданное число раз.  
Встроить отображение текста (в qt через qml объект Text, в шарпах гуглите). 
Научиться засекать время между вызовами (в qt QElapsedTimer или std::chrono::…, в шарпах гуглите) и встроить отображение текущей частоты кадров как обратную величину к этому времени (кадров в секунду).  
Добавить настройку для задания количества объектов в таких пределах, чтобы при максимальном числе объектов частота отображения кадров падала до одного кадра в секунду.

Задача 4 
Рендеринг с учетом освещения в каждом пикселе 
Цель задания  
Реализовать в пиксельном шейдере формулу Фонга для локальной модели освещения для разных типов источников света (направленный свет, точечный источник света, прожектор).  
Сравнить с задачей №2 (визуальное качество изображения и скорость рендеринга). 
Задача в общих словах 
Одноцветный кубик должен иметь разную интенсивность/яркость цвета на гранях с разным углом поворота к источнику освещения (в соответствии с формулой Фонга) без дефектов интерполяции освещенности на больших или вытянутых гранях. 
Приблизительный алгоритм выполнения задания  
Взять приложение из задачи 3.  
Изменить алгоритм генерации треугольников в кубе, чтобы получились длинные грани, например, так: 

Убедиться, что при близком рассмотрении на таких гранях интерполяция освещения выглядит некорректно.  
Перенести реализацию локальной модели освещения по Фонгу из вершинного шейдера в пиксельный (при этом научиться корректно передавать параметры из одного шейдера в другой).  
Убедиться, что дефект интерполяции освещения пропал.  
Сравнить частоту кадров для задачи №2 и задачи № 4 при отображении сцен одинаковой сложности (важно увеличивать сложность сцены до тех пор, пока частота кадров не станет меньше 60 кадров в секунду в обеих задачах).
Основное задание
Материалы для изучения
 
Начинать стоит именно с этих уроков, всё разложено последовательно и  понятно
https://learnopengl.com/
 
По большей части хорошие и интересные уроки по OpenGL, наверно не стоит всё смотреть, только интересующие кусочки если будет желание или вопросы
https://thecherno.com/opengl
 
Тут автор много интересного и полезного рассказывает и показывает как в контексте opengl, так и игровых движков, внутрянки и архитектуры
https://thecherno.com/engine
 
Дока (уроки) по OpenTK
https://opentk.net/learn/index.html
 
Также для ознакомления с работой движков и тем, как это выглядит “для пользователя” можно поработать на Unity (там как раз скриптовый язык C#), обратить внимание стоит на то, как идёт работа с объектами сцены и компонентами (которые GameObject и Component), скриптами (которые тоже компоненты) и материалами.
 
Если, как говорил один преподаватель, вы “ощущаете легкость бытия” можно углубиться в подкапотную математику
http://songho.ca/opengl/index.html
 
В этом, достаточно небольшом, проекте показан один из способов организации работы с моделями, геометрией, шейдерами и сценами.
https://github.com/Altair200333/AloyEngine

При использовании DirectX рекомендуется данное видео к просмотру

https://youtu.be/-xM2rmYN5YY
Для использования DirectX на языке C# необходимо использовать библиотеку SharpDX
Технологии
 
Несмотря на то, что приведенные выше материалы рассчитаны на C++, всё рассказанное там применимо и к другим языкам, так для них зачастую существуют библиотеки, оборачивающие функционал графического api.
 
Задания выполняются на языке C#, в качестве той самой обвязки вокруг OpenGL выступает OpenTK, а интерфейс на WPF и/или ImGui (позволяет очень просто делать интерактивный интерфейс, как привязать ImGui к OpenTK можно найти тут)
 
Итого: C#, OpenTK, ImGui (по желанию)
 
P.S. Не весь функционал OpenGL, представленный для C++ находит “точное” отражение на C#, в таких случаях можно погуглить, как правило народ с этим сталкивается и указывает названия нужных методов.
 
Задания
Указания:
Выполнять каждое задание можно как в отдельном проекте, так и в общем, где каждому заданию будет соответствовать своя сцена.
 
Проект надо вести на github, в приватном репозитории, добавив в него Аркадия
 
В некоторых заданиях есть “доп. функционал”, который не обязателен на текущем этапе, но упростит дальнейшую работу.
 
Задачи:
 
Вьюпорт
Шейдеры
Работа с геометрией
Визуализация грида
Слайсы
Проект
Вьюпорт
Создать вьюпорт (окошко с графикой), в котором отображается какая-нибудь примитивная геометрия (треугольник, куб, плоскость и т.д.)
 
Доп. функционал:
ImGui слайдер, с помощью которого можно перемещать или вращать объект (модифицировать матрицу модели)
Перемещение камеры на клавиши WASD и повороты мышкой(происходит захват мыши)
Переключение с режима WASD на режим работы с мышью (ЛКМ - вращение, СКМ - перемещений, колёсико как и п. 2 зум)
 
Шейдеры
Добавить загрузку шейдеров, чтение из файла и компиляция.
Реализовать простое освещение с переменным числом источников разных типов (точечных и направленных).
Перемещение камеры с клаво-мыши.
 
На выходе должна быть сцена с какой-то геометрией (кубы, сферы, и т.д.) с разбросанными источниками света, по которой можно полетать.
 
Доп. функционал:
Добавить изменение uniform параметров через интерфейс (цвета, “зеркальность”, положения и цвета источников освещения).
Переключение в режим отображения сетки моделей (glPolygonMode)
Задание вершинных цветов (vertex color)
Toon shading - уменьшение количества используемых цветов, грубо говоря дискретизация цветовой палитры.
 
Работа с геометрией
Загрузка поверхностей из .txt файла (подробнее о формате позже, пока - поверхность состоит из квадов)
Отображение сетки поверхности, как поверх неё, так отдельно.
 
Отображение скважин - как линии и как трубы (то есть генерация меша)
 
Задание свойств поверхностям. Свойство это float значение, назначаемое на каждую ячейку (квад) объекта, в соответствии с этим значение каждый полигон красится в определенный цвет, в соответствии с заданной палитрой. Если палитра выглядит как на картинке, то ячейки с минимальным значением будут оранжевыми, а с максимальным - фиолетовыми.
 
Задавать свойства можно как через вершинные цвета, так и через передаваемую палитру и какой-нибудь вершинный атрибут для хранения значения.
 
Доп. функционал:
Изменение свойства на лету, возможность переключать отображаемое свойство
Изменение палитры из интерфейса
Покраска поверхности градиентом по высоте
 
Визуализация грида
Все необходимые данные лежат тут 
Задача, как и для поверхностей - нарисовать грид со свойствами и возможностью их переключать, желательно добавить отображение сетки.
 
Грид это представление земного пласта путем разбиения его в виде шестигранных ячеек.
 
Каждая ячейка состоит из 8 точек, пронумерованных как на рисунке.
То есть грид по сути является трехмерным массивом описанных выше ячеек.
 
Ячейки грида обычно индексируются тремя числами - I, J, K
I, J - горизонталь (см. рисунок)
K   - вертикаль
 
На каждую ячейку назначается так называемое свойство - float значение. Затем ячейка красится в некоторый цвет исходя из градиента (как и поверхность).
 
Храниться грид будет в бинарнике, свойства к нему в отдельном .txt файле
 
Сначала храняться размеры по i, j, k - int поля
Далее в таком цикле записываются ячейки (картинка чтобы был понятен порядок развёртки, в каком читать)
 
Для каждой ячейки записано bool поле, активна ли она
Для каждого угла записано XYZ значение верхней и нижней крышки
 
В файле со свойствами первым полем записано их количество.
Далее для каждого свойства идёт набор float значений, их количество равно количеству ячеек грида.
Развертка при записи вот такая:
 
 Слайсы
Необходимо реализовать возможность просматривать грид по слайсам или, другими словами, по слоям. 

 Результат должен выглядеть так:

грид со свойствами

Срез грида (так называемый слайс) по K и J

Проект
Пока не рассматриваем эту часть
 


